const PDFDocument = require("pdfkit");

const pad = (value) => value.toString().padStart(2, "0");

const formatDateTime = (value) => {
  if (!value) return "N/A";
  const date = value instanceof Date ? value : new Date(value);
  if (Number.isNaN(date.getTime())) return "N/A";
  return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}`;
};

const formatCurrency = (value) => {
  if (typeof value !== "number") return "N/A";
  return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(value);
};

const buildBufferFromDoc = (buildFn) =>
  new Promise((resolve, reject) => {
    const doc = new PDFDocument({ size: "A4", margin: 40 });
    const chunks = [];

    doc.on("data", (chunk) => chunks.push(chunk));
    doc.on("end", () => resolve(Buffer.concat(chunks)));
    doc.on("error", (error) => reject(error));

    buildFn(doc);

    doc.end();
  });

const addReportHeader = (doc, title, metadata = {}) => {
  doc.fontSize(20).text("Library Management System", { align: "center" });
  doc.moveDown(0.3);
  doc.fontSize(16).text(title, { align: "center" });
  doc.moveDown();

  const entries = Object.entries(metadata).filter(([, value]) => Boolean(value));
  if (entries.length) {
    doc.fontSize(11).fillColor("#555");
    entries.forEach(([key, value]) => {
      doc.text(`${key}: ${value}`);
    });
    doc.fillColor("#000");
    doc.moveDown();
  }
};

const addSectionDivider = (doc) => {
  const { x, y } = doc;
  doc
    .moveTo(x, y)
    .lineTo(doc.page.width - doc.page.margins.right, y)
    .lineWidth(0.5)
    .strokeColor("#CCCCCC")
    .stroke()
    .strokeColor("#000000");
  doc.moveDown(0.5);
};

const generateBorrowingReportPdf = async (records, { filters = {}, generatedBy }) => {
  return buildBufferFromDoc((doc) => {
    addReportHeader(doc, "Borrowing Report", {
      "Generated On": formatDateTime(new Date()),
      "Generated By": generatedBy,
      ...(filters.startDate ? { "Start Date": filters.startDate } : {}),
      ...(filters.endDate ? { "End Date": filters.endDate } : {}),
      ...(filters.status ? { Status: filters.status } : {}),
      ...(filters.user ? { "User ID": filters.user } : {}),
      ...(filters.book ? { "Book ID": filters.book } : {}),
    });

    const totalRecords = records.length;
    const statusSummary = records.reduce((acc, borrow) => {
      const status = borrow.status || "unknown";
      acc[status] = (acc[status] || 0) + 1;
      return acc;
    }, {});

    doc.fontSize(12).text(`Total Records: ${totalRecords}`);
    if (totalRecords) {
      doc.fontSize(12).text("Status Summary:");
      doc.fontSize(11).fillColor("#555");
      Object.entries(statusSummary).forEach(([status, count]) => {
        doc.text(`• ${status}: ${count}`);
      });
      doc.fillColor("#000");
    } else {
      doc.moveDown();
      doc.fontSize(12).text("No borrowing records found for the selected filters.");
    }

    doc.moveDown();
    addSectionDivider(doc);

    records.forEach((borrow, index) => {
      const user = borrow.user || {};
      const book = borrow.book || {};

      doc.fontSize(12).text(`#${index + 1} - ${book.title || "Unknown Book"}`, { continued: false });
      doc.fontSize(10).fillColor("#555").text(`Member: ${user.username || "N/A"} (${user.email || "N/A"})`);
      doc.text(`Status: ${borrow.status || "N/A"}`);
      doc.text(
        `Borrowed: ${formatDateTime(borrow.borrowDate)} | Due: ${formatDateTime(borrow.dueDate)} | Returned: ${formatDateTime(borrow.returnDate)}`
      );
      doc.text(`Created: ${formatDateTime(borrow.createdAt)} | Updated: ${formatDateTime(borrow.updatedAt)}`);
      doc.fillColor("#000");
      doc.moveDown(0.5);
      addSectionDivider(doc);
    });
  });
};

const generatePaymentReportPdf = async (records, { filters = {}, generatedBy }) => {
  return buildBufferFromDoc((doc) => {
    addReportHeader(doc, "Payment Report", {
      "Generated On": formatDateTime(new Date()),
      "Generated By": generatedBy,
      ...(filters.startDate ? { "Start Date": filters.startDate } : {}),
      ...(filters.endDate ? { "End Date": filters.endDate } : {}),
      ...(filters.status ? { Status: filters.status } : {}),
      ...(filters.plan ? { Plan: filters.plan } : {}),
    });

    const totalRecords = records.length;
    const totalAmount = records.reduce((sum, payment) => sum + (payment.amount || 0), 0);
    const statusSummary = records.reduce((acc, payment) => {
      const status = payment.status || "unknown";
      acc[status] = (acc[status] || 0) + 1;
      return acc;
    }, {});

    doc.fontSize(12).text(`Total Records: ${totalRecords}`);
    doc.fontSize(12).text(`Total Amount: ${formatCurrency(totalAmount)}`);

    if (totalRecords) {
      doc.fontSize(12).text("Status Summary:");
      doc.fontSize(11).fillColor("#555");
      Object.entries(statusSummary).forEach(([status, count]) => {
        doc.text(`• ${status}: ${count}`);
      });
      doc.fillColor("#000");
    } else {
      doc.moveDown();
      doc.fontSize(12).text("No payment records found for the selected filters.");
    }

    doc.moveDown();
    addSectionDivider(doc);

    records.forEach((payment, index) => {
      const user = payment.user || {};
      doc.fontSize(12).text(`#${index + 1} - ${user.username || "Unknown User"}`);
      doc.fontSize(10).fillColor("#555").text(`Email: ${user.email || "N/A"}`);
      doc.text(`Plan: ${payment.plan || "N/A"} | Amount: ${formatCurrency(payment.amount)}`);
      doc.text(`Status: ${payment.status || "N/A"}`);
      doc.text(
        `Submitted: ${formatDateTime(payment.submittedAt)} | Approved: ${formatDateTime(payment.approvedAt)} | Rejected: ${formatDateTime(payment.rejectedAt)}`
      );
      if (payment.rejectedReason) {
        doc.text(`Rejection Reason: ${payment.rejectedReason}`);
      }
      doc.text(`Created: ${formatDateTime(payment.createdAt)} | Updated: ${formatDateTime(payment.updatedAt)}`);
      doc.fillColor("#000");
      doc.moveDown(0.5);
      addSectionDivider(doc);
    });
  });
};

module.exports = {
  generateBorrowingReportPdf,
  generatePaymentReportPdf,
};


